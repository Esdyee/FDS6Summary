#DOM 정의
-------------
DOM(문서객체모델)은 다양한 언어들이 문서에 접근할 수 있는 지점(인터페이스)이자 브라우저 렌더링의 결과물이라 할 수 있다. 객체라는 단어가 붙은 이유는 웹문서 파싱의 결과로 HTML태그들이 객체(노드)로 변했다는 사실에 있다. 문서 안 들어있는 정보를 표현하는 과정에서 발생하는 중첩관계(div > p > a) 등으로 인해 나무(tree)와 같은 형태를 띄게 된다.

참고)
관점에 따라 달라지는 DOM의 정의
http://rhio.tistory.com/198

##노드의 종류
-------------
DOM Tree를 살펴보면 노드의 종류는 총 네 가지로 분류된다.
1.문서 노드(Document, 돔 트리 구조의 최상단을 차지하는 객체) 
2.요소 노드(태그가 객체화된 결과. Attribute와 자식 노드인 텍스트노드에 접근하기 위한 시작점이 되는 객체)
3.어트리뷰트 노드(요소노드의 특성을 담는 노드)
4.텍스트 노드(돔 트리 구조의 최종단. 자신이 최종단이므로 자식노드를 가질 수 없다.)

![Nodes in Dom Tree ](http://poiemaweb.com/img/dom-tree.png)


#DOM Tree 생성과정
-------------
브라우저에 있는 렌더링 엔진(웹킷,겍코)과 별도의 자바스크립트 엔진이 파일로 된 HTML,css,js를 로딩하고 한줄씩 파싱한다. 이 때 파서가 세 언어의 신택스를 알고 있어서 적절하게 읽어 나간다. 파싱된 결과를 메모리에 저장하고 2진수로 저장되기 전에 해석결과를 '객체화'하는데 이를 DOM이라 한다.

구글에서 제공하는 DOM Tree 생성과정
:UTF-8 변환 전 원시 코드 > 문자 > 토큰(요소/속성/값으로 각기 나뉘어진 문자) > (파서가 토큰 해석 뒤) 노드 객체 > DOM Tree 추가
https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model?hl=ko

#DOM에 접근해서 요소,속성,텍스트를 바꾸는 API(함수)
-------------
DOM은 다양한 언어가 인터페이스 독립적인 성격을 가진다. 돔 관리 언어가 되려면 두 가지 조건을 충족해야 하는데, 그 중 DOM구조에 접근해서 원하는 요소/속성/텍스트를 수정할 수 있는지가 중요하다. 아래는 DOM구조에 접근할 수 있는 API들의 목록이다.

##API의 종류
1. 하나의 요소 노드에 접근하는 API
    1.document.getElementById(id)
    :인자에 해당하는 Id를 가진 요소 노드에 접근한다. 
    
    2.document.querySelector(cssSelector)
    :인자(CSS셀렉터)가 가리키는 요소 노드에 접근한다.
    :IE8이상의 브라우저에서 동작한다.

2. 두 개 이상의 요소 노드에 접근하는 API
    1.document.getElementsByCalssName(class)
    : 인자 class를 가진 모든 요소 노드에 접근한다.
    : 반환값 HTMLCollection(live) // 크롬 기준 
    : IE9이상의 브라우저에서 동작한다.
    
    2.document.getElementsByTagName(tagName)
    : 인자 tagName을 가진 모든 요소 노드에 접근한다.
    : 반환값 HTMLCollection(live)
    : 모든 브라우저에서 동작
    
    3.document.querySelectorAll(selector)
    : 인자(CSS셀렉터)가 가리키는 모든 요소 노드에 접근한다.
    : 반환값 NodeList(non-live)
    
      *반환값 NodeList와 HTMLCollection의 차이
      : HTMLCollection(live)은 유사배열 객체로, 실시간으로 document가 변경되면 그 변경사항을 반영한다. 특정 조건이 만족되면 프로퍼티에서 빠져나가기 때문에 반복문에 활용할 때 주의해야한다. 단,document.getElementByName의 경우 반환값이 NodeList지만 live의 성격을 지닌다. 
      
      또한, NodeList는 노드 타입 전부를 포함할 수 있으며, HTMLCollection 객체는 엘리먼트 노드만을 포함시킨다.
    
3. 요소/어트리뷰트/텍스트에 접근하는 API
   요소에 접근하는 API
    1.parentNode
    : 접근한 요소 노드의 부모 노드에 접근한다.

    2.firstChild/lastChild
    : 접근한 요소 노드의 자식 노드에 접근한다.
    : IE9이상의 브라우저에서 동작한다.

    3.hasChildNodes()/childNodes()
    4.previousSibling()/nextSibling()

    *주의할 점은 firstChild/lastChild를 사용했을 때, 의도와 다르게 태그 사이에 존재하는 '빈 칸'에 접근할 수도 있다. DOM Interface에선 빈 칸을 텍스트 노드로 인식하기 때문이다. 제이쿼리가 제공하는 jQuery:.prev()/.next()를 사용하면 공백을 노드로 인식하는 문제를 해결할 수 있다. 이처럼 제이쿼리가 DOM 인터페이스가 주는 불편함을 해소하고 크로스 브라우징 문제를 해결하는 등 여러 편의성을 제공하지만, 최근 Angular JS와 같은 프레임워크에선 HTML의 관점에서 자바스크립트를 조작하기 시작하면서 반대 방향으로 작동하는 제이쿼리의 사용 빈도가 줄어들고 있다.
   
   어트리뷰트에 접근하는 API
    1.document.getElementsByTagName.className/id(value)
    :class/id 어트리뷰트 값을 얻거나 수정한다. class는 값이 여러 개일 경우, 배열로 전환시키는 것이 좋다
    2.hasAttribute(attribute)/getAttribute(attribute)/setAttribute(arrtribtue, value)/removeAttribute(attribute)
   
   텍스트 노드에 접근하는 API
    1.nodeValue : 텍스트 노드의 값에 접근
    2.nodeType/nodeName : 텍스트 노드의 프로퍼티로 노드 유형과 선택된 요소가 가진 노드의 이름을 확인할 수 있다.
4. 콘텐츠(태그와 태그사이에 존재하는 요소,속성,텍스트)에 접근하고 조작하는 API
    1.textContent
    : 요소의 텍스트 콘텐츠에 접근
    
    2.innerHTML
    : 요소의 모든 하위 요소 문자열로 취득. 문자열에 마크업 태그를 넣으면 동작한다. 이 점으로 인해 페이지에서 댓글 입력을 innerHTML로 관리하는 경우 악성 스크립트 공격을 받을 수 있다.

5. CSS 인라인 스타일에 접근하는 API
    1. 변수.style.style_property  = "value"
    : 인라인 스타일로 접근해서 CSS효과를 준다.

